package at.iaik.teaching.sase.ku2013.crypto;

import iaik.asn1.CodingException;
import iaik.pkcs.pkcs12.KeyFactory;
import iaik.security.provider.IAIK;
import iaik.utils.SSLeayPrivateKey;
import iaik.x509.ChainVerifier;
import iaik.x509.X509Certificate;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CertificateException;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Tools for cryptography and PKI related operations.
 */
public final class CryptoToolBox {

	/**
	 * Algorithm name of the AES cipher (For key related operation).
	 * 
	 * @see CryptoToolBox#generateSecretKey
	 * @see CryptoToolBox#importSecretKey
	 * @see CryptoToolBox#unWrapKey
	 */
	public static final String KEY_ALG_AES = "AES";

	/**
	 * Length of the AES key to be created.
	 * 
	 * @see CryptoToolBox#generateSecretKey
	 */
	public static final int AES_KEY_LEN = 128;

	/**
	 * Length of the initial value used for AES-CCM operations.
	 * 
	 * @see CryptoToolBox#aesCcmEncrypt
	 * @see CryptoToolBox#aesCcmDecrypt
	 * 
	 */
	public static final int AES_CCM_IV_SIZE = 13;

	/**
	 * Algorithm name of the HMAC-SHA1 MAC (For key related operation).
	 * 
	 * @see CryptoToolBox#generateSecretKey
	 * @see CryptoToolBox#importSecretKey
	 * @see CryptoToolBox#unWrapKey
	 */
	public static final String KEY_ALG_HMAC_SHA1 = "HmacSHA1";

	/**
	 * Algorithm name of the HMAC-SHA1 MAC. (For HMAC computation)
	 * 
	 * @see CryptoToolBox#computeHmac
	 * @see CryptoToolBox#verifyHmac
	 */
	public static final String MAC_ALG_HMAC_SHA1 = "HmacSHA1";

	/**
	 * Algorithm name of the AES cipher in CCM mode without padding.
	 * 
	 * @see CryptoToolBox#aesCcmEncrypt
	 * @see CryptoToolBox#aesCcmDecrypt
	 */
	public static final String ENC_ALG_AES_CCM_NOPADDING = "AES/CCM/NoPadding";

	/**
	 * Algorithm name of the RSA cipher in ECB mode with PKCS1 padding.
	 * 
	 * @see CryptoToolBox#wrapKey
	 * @see CryptoToolBox#unWrapKey
	 */
	public static final String ENC_ALG_RSA_ECB_PKCS1 = "RSA/ECB/PKCS1Padding";

	/**
	 * Algorithm name of the RSA signature algorithm with SHA1 hash.
	 * 
	 * @see CryptoToolBox#packAndSignBlob
	 * @see CryptoToolBox#verifyBlobAndUnpack
	 */
	public static final String SIG_ALG_RSA_SIG_SHA1 = "SHA1withRSA";

	/**
	 * Name of the IAIK JCE provider for use in various getInstance methods.
	 */
	public final static String IAIK_PROVIDER = "IAIK";

	/**
	 * Shared random number generator instance. (System entropy depletion
	 * workaround for virtual machine users.)
	 * 
	 * See the remarks below in the static constructor and the
	 * {@link CryptoToolBox#getSecureRandom} method for more details.
	 */
	private static final SecureRandom sharedRNG;

	// Static constructor used to register the IAIK JCE provider
	static {
		// Add the IAIK provider
		IAIK.addAsProvider();

		// See the getSecureRandom method for more details.
		//
		// Virtual machine users (VMware image!) may want to replace
		// the following line with:
		// sharedRNG = new SecureRandom();
		sharedRNG = null;
	}

	// Utility class, no public constructor
	private CryptoToolBox() {
	}

	/**
	 * Loads an encrypted or unencrypted private key in OpenSSL's PEM format.
	 * 
	 * This function is able to load encrypted and unencrypted private keys in
	 * the PEM format generated by OpenSSL. The password parameter is mandatory
	 * for loading encrypted private keys (it is silently ignored for
	 * unencrypted keys).
	 * 
	 * @param is
	 *            Source stream to load the key from.
	 * 
	 * @param password
	 *            Password for decrypting the private key. (can be null for
	 *            unencrypted keys only).
	 * 
	 * @return The Java {@link PrivateKey} object extracted from the input file.
	 * 
	 * @throws InvalidKeyException
	 *             if the key (or password) is invalid.
	 * 
	 * @throws IOException
	 *             if the input stream can not be read.
	 */
	public static PrivateKey loadPemPrivateKey(InputStream is, char[] password)
			throws InvalidKeyException, IOException {

		SSLeayPrivateKey encoded_key = new SSLeayPrivateKey(is);

		// Try to decrypt if the key is encrypted
		if (encoded_key.isEncrypted()) {
			if (password == null) {
				throw new InvalidKeyException(
						"Private key can not be decrypted without a password.");
			}

			// NOTE: The SSLeayPrivateKey API does not (yet) provide a character
			// array based interface for the password.
			encoded_key.decrypt(new String(password));
		}

		return encoded_key.getPrivateKey();
	}

	/**
	 * Stores an encrypted or unencrypted private key in OpenSSL's PEM formar.
	 * 
	 * This function is able to store encrypted and unencrypted private keys in
	 * the PEM format understood by OpenSSL. The password parameter controls if
	 * the generated PEM file should be encrypted (no encryption will be done
	 * when the password is null).
	 * 
	 * @param os
	 *            Output stream to write the key to.
	 * @param key
	 *            Private key object to be stored.
	 * 
	 * @param password
	 *            Optional password used for encryption. This parameter can be
	 *            {@code null} to store the key without any encryption.
	 * 
	 * @throws CodingException
	 * @throws GeneralSecurityException
	 * @throws NoSuchAlgorithmException
	 * @throws IOException
	 */
	public static void savePemPrivateKey(OutputStream os, PrivateKey key,
			char[] password) throws CodingException, NoSuchAlgorithmException,
			GeneralSecurityException, IOException {

		SSLeayPrivateKey pem_key = new SSLeayPrivateKey(key);

		if (password != null) {
			// Encrypt with default parameters:
			// * Triple-DES cipher in CBC mode (DES-EDE3-CBC)
			// * Random IV
			//
			// NOTE: The SSLeayPrivateKey API does not (yet) provide a character
			// array based interface for the password.
			pem_key.encrypt(new String(password), null, null);
		}

		// And store the results
		pem_key.writeTo(os);
	}

	/**
	 * Loads an encrypted or unencrypted private key in OpenSSL's PEM format.
	 * 
	 * This function is able to load encrypted and unencrypted private keys in
	 * the PEM format generated by OpenSSL. The password parameter is mandatory
	 * for loading encrypted privat keys (it is silently ignored for unencrypted
	 * keys).
	 * 
	 * @param file_name
	 *            Name of the source file to load.
	 * 
	 * @param password
	 *            Password for decrypting the private key. (can be null for
	 *            unencrypted keys only).
	 * 
	 * @return The Java {@link PrivateKey} object extracted from the input file.
	 * 
	 * @throws InvalidKeyException
	 *             if the key (or password) is invalid.
	 * 
	 * @throws IOException
	 *             if the input stream can not be read.
	 */
	public static PrivateKey loadPemPrivateKey(String file_name, char[] password)
			throws InvalidKeyException, IOException {
		FileInputStream is = new FileInputStream(file_name);
		try {
			return loadPemPrivateKey(is, password);
		} finally {
			is.close();
		}
	}

	/**
	 * Loads an X.509 public key certificate from an input stream.
	 * 
	 * @param is
	 *            The input stream containing the certificate data.
	 * 
	 * @return The newly loaded certificate.
	 * 
	 * @throws CertificateException
	 *             thrown if a certificate is unparsable. This exception does
	 *             NOT provide an indication of the validity of a certificate.
	 * 
	 * @throws IOException
	 *             thrown in case of I/O problems.
	 */
	public static X509Certificate loadCertificate(InputStream is)
			throws CertificateException, IOException {
		return new X509Certificate(is);
	}

	/**
	 * Loads an X.509 public key certificate from a given file.
	 * 
	 * @param file_name
	 *            Name of the input file for loading the certificate.
	 * 
	 * @return The newly loaded certificate.
	 * 
	 * @throws CertificateException
	 *             thrown if a certificate is unparsable. This exception does
	 *             NOT provide an indication of the validity of a certificate.
	 * 
	 * @throws IOException
	 *             thrown in case of I/O problems.
	 */
	public static X509Certificate loadCertificate(String file_name)
			throws IOException, CertificateException {
		FileInputStream is = new FileInputStream(file_name);
		try {
			return loadCertificate(is);
		} finally {
			is.close();
		}
	}

	/**
	 * Tries to construct an X.509 certificate chain from the {@code leaf}
	 * certificate up to a (self-signed) root certificate.
	 * 
	 * This method internally uses {@link ChainVerifier#orderCertificateChain}
	 * to sort the certificate chain. This method fails if more than one path to
	 * a trusted root certificate exist (which may be the case for
	 * cross-certification).
	 * 
	 * @param leaf
	 *            the leaf certificate of the chain.
	 * 
	 * @param all_certs
	 *            array of certificates which are available for chain
	 *            construction.
	 * 
	 * @return An array containing the certificate chain of the {@code leaf}
	 *         certificate. The {@code leaf} certificate is at index 0, the root
	 *         certificate is the last element of the array.
	 * 
	 * @throws CertificateException
	 *             thrown if the {@link ChainVerifier#orderCertificateChain}
	 *             fails to construct a certificate chain.
	 */
	public static X509Certificate[] orderCertificateChain(X509Certificate leaf,
			X509Certificate[] all_certs) throws CertificateException {

		// Let the ChainVerifier#orderCertificateChain method do the heavy
		// lifting.
		// Note that this method returns an array of
		// java.security.cert.X509Certificate
		// objects instead of an iaik.x509.X509Certificate array.
		//
		// Due to Java's type-system rules it is possible to assign
		// an array of iaik.x509.X509Certificate object
		// to an array of java.security.cert.X509Certificate objects, while the
		// opposite direction is forbidden.
		//
		// (You can assign an array of a derived class type to an array of the
		// base class type, but not vice versa.)
		//
		// This method hides the casting and returns an array of
		// iaik.x509.X509Certificate objects.
		java.security.cert.X509Certificate[] chain = ChainVerifier
				.orderCertificateChain(leaf, all_certs);

		// Copy and cast ...
		iaik.x509.X509Certificate[] result = new iaik.x509.X509Certificate[chain.length];
		for (int n = 0; n < chain.length; ++n) {
			result[n] = (iaik.x509.X509Certificate) chain[n];
		}

		// ... now the type system is happy again :)
		return result;
	}

	/**
	 * Stores an encrypted or unencrypted private key in OpenSSL's PEM formar.
	 * 
	 * This function is able to store encrypted and unencrypted private keys in
	 * the PEM format understood by OpenSSL. The password parameter controls if
	 * the generated PEM file should be encrypted (no encryption will be done
	 * when the password is null).
	 * 
	 * @param file_name
	 *            Name of the the output file.
	 * 
	 * @param key
	 *            Private key object to be stored.
	 * 
	 * @param password
	 *            Optional password used for encryption. This parameter can be
	 *            {@code null} to store the key without any encryption.
	 * 
	 * @throws CodingException
	 * @throws GeneralSecurityException
	 * @throws NoSuchAlgorithmException
	 * @throws IOException
	 */
	public static void savePemPrivateKey(String file_name, PrivateKey key,
			char[] password) throws CodingException, NoSuchAlgorithmException,
			GeneralSecurityException, IOException {

		FileOutputStream os = new FileOutputStream(file_name);
		try {
			savePemPrivateKey(os, key, password);
		} finally {
			os.close();
		}

	}

	/**
	 * Helper method to duplicate a part of a byte array.
	 * 
	 * @param src
	 *            Source byte array.
	 * @param offset
	 *            Offset (index) of the first byte to duplicate.
	 * @param length
	 *            Number of bytes to duplicate.
	 * @return A duplicate of the selected byte range.
	 */
	public static byte[] dupBytes(byte[] src, int offset, int length) {
		byte[] dst = new byte[length];
		System.arraycopy(src, offset, dst, 0, length);
		return dst;
	}

	/**
	 * Get secure random number generator.
	 * 
	 * Certain cryptographic operations like key generation, encryption and
	 * signature generation require large amounts of random numbers. Normally
	 * the random number generators are automatically selected by the
	 * {@code init} methods of the {@link KeyGenerator},
	 * {@link KeyPairGenerator}, {@link Cipher} and {@link Signature} classes.
	 * 
	 * The defalut behavior is to create a fresh random number generator for
	 * each {@code init} call and to seed it from system-wide entropy sources.
	 * This can be a problem in Virtual Machine environments, where the
	 * available entropy for seeding the random number generators is very low.
	 * 
	 * When using VMware you typically observe significant slowdowns after the
	 * first few key generation operations. Moving the mouse (and thus providing
	 * additional entropy) sometimes help a bit ...
	 * 
	 * Fortunately the {@code init} methods of the affected JCE classes allow
	 * explicit specification of the random number generator to be used. See the
	 * {@link CryptoToolBox#generateRsaKeyPair} method for an example, similar
	 * variants of the {@code init} methods also exist for the
	 * {@link KeyGenerator}, {@link Cipher} and {@link Signature} classes.
	 * 
	 * You can try to solve entropy depletion problems by using this method for
	 * obtaining your random number generators. Setting the
	 * {@link CryptoToolBox#sharedRNG} to a non-null object should then solve
	 * your issues (at the cost of a slight decrease in security, which is
	 * acceptable for debugging purposes).
	 * 
	 * @return A secure random number generator instance.
	 */
	public static SecureRandom getSecureRandom() {
		// VM User workaround: Use our globally RNG if available:
		if (sharedRNG != null) {
			return sharedRNG;
		}

		// Construct a default secure random number generator (which
		// will seed itself automatically on first use)
		return new SecureRandom();
	}

	/**
	 * Generates random bytes using a secure random number generator.
	 * 
	 * @param length
	 *            The number of random byte to generate.
	 * 
	 * @return The requested random byte array.
	 */
	public static byte[] getRandomBytes(int length) {
		byte[] bytes = new byte[length];
		getSecureRandom().nextBytes(bytes);
		return bytes;
	}

	/**
	 * Computes the HMAC-SHA1 check value of a given source byte array.
	 * 
	 * This method computes the HMAC value of the byte array slice defined by
	 * {@code src}, {@code offset} and {@code length} using the secret key given
	 * by the {@code key} parameter.
	 * 
	 * The HMAC algorithm used by this method is the SHA1-based {@code HmacSHA1}
	 * algorithm provided by the Java cryptography framework.
	 * 
	 * @param src
	 *            Source byte array for HMAC computation.
	 * @param offset
	 *            Offset (index) of the first source byte to be processed by the
	 *            HMAC.
	 * @param length
	 *            Number of bytes to be processed by the HMAC.
	 * @param key
	 *            Secret key for computing the HMAC.
	 * 
	 * @return A new byte array containing the HMAC-SHA1 value of the selected
	 *         byte array slice.
	 * 
	 * @throws NoSuchAlgorithmException
	 *             is thrown if the JCE provider does not recognize
	 *             {@code HmacSHA1} as valid HMAC algorithm.
	 * 
	 * @throws NoSuchProviderException
	 *             is thrown if the JCE provider does not recognize the
	 *             {@code IAIK} JCE cryptography provider.
	 * 
	 * @throws InvalidKeyException
	 *             is thrown if the HMAC engine does not accept the key given in
	 *             {@code key}.
	 */
	public static byte[] computeHmac(byte[] src, int offset, int length,
			SecretKey key) throws NoSuchAlgorithmException,
			NoSuchProviderException, InvalidKeyException {

		// Parameter checks
		if (src == null) {
			throw new IllegalArgumentException(
					"Source byte array must not be null");
		} else if (key == null) {
			throw new IllegalArgumentException("HMAC key must not be null");
		}

		// TODO: Compute the HmacSHA1 value over the source bytes using the
		// given key.

		// -----BEGIN STUDENT CODE-----
		if (offset < 0 || offset >= src.length)
			throw new IllegalArgumentException(
					"offset must be in the range of [0, src.length[");
		if (length <= 0 || length + offset > src.length)
			throw new IllegalArgumentException(
					"lenght must be in the range ]0, src.length-offset]");
		
		Mac hmac_alg = Mac.getInstance(MAC_ALG_HMAC_SHA1);
		hmac_alg.init(key);
		byte[] slice = Arrays.copyOfRange(src, offset, offset + length);
		return hmac_alg.doFinal(slice);
		// -----END STUDENT CODE-----
	}

	/**
	 * Verifies the integrity and authenticity of a data in a byte-array using
	 * an HMAC.
	 * 
	 * To verify the selected slice of the source byte array, this method first
	 * computes an HMAC over the source bytes using
	 * {@link CryptoToolBox#computeHmac} method. Then the computed HMAC is
	 * compared byte-wise with the expected given by the {@code hmac} parameter.
	 * 
	 * @param src
	 *            Source byte array containing the data to be verified. This
	 *            array usually comes from an untrusted source.
	 * 
	 * @param src_offset
	 *            Offset (index) of the first data byte to be included in the
	 *            HMAC computation.
	 * 
	 * @param src_length
	 *            Number of data-bytes to be included in the HMAC computation.
	 * 
	 * @param key
	 *            Secret key for computing the HMAC of the source data bytes.
	 * 
	 * @param hmac
	 *            Expected HMAC value of the source data bytes.
	 * 
	 * @return True if the integrity and authenticity of the selected source
	 *         bytes could be verified, false otherwise. Verification succeeds
	 *         if and only if the HMAC computed over the selected source bytes
	 *         using the key given by the {@code key} parameter is equal to the
	 *         expected HMAC value given by the {@code hmac} parameter.
	 * 
	 * @throws NoSuchAlgorithmException
	 *             is thrown if the JCE provider does not recognize
	 *             {@code HmacSHA1} as valid HMAC algorithm.
	 * 
	 * @throws NoSuchProviderException
	 *             is thrown if the JCE provider does not recognize the
	 *             {@code IAIK} JCE cryptography provider.
	 * 
	 * @throws InvalidKeyException
	 *             is thrown if the HMAC engine does not accept the key given in
	 *             {@code key}.
	 */
	public static boolean verifyHmac(byte[] src, int src_offset,
			int src_length, SecretKey key, byte[] hmac)
			throws InvalidKeyException, NoSuchAlgorithmException,
			NoSuchProviderException {

		// TODO: Compute the HmacSHA1 value over the source bytes using the
		// given key. Then compare the compute HMAC against the given HMAC to
		// verify
		// the integrity of your message.
		//
		// Your method should return true if (and only if) the computed and the
		// given HMAC match.

		// -----BEGIN STUDENT CODE-----
		if (src_offset < 0 || src_offset >= src.length)
			throw new IllegalArgumentException(
					"src_offset must be in the range of [0, src.length[");
		if (src_length <= 0 || src_length + src_offset > src.length)
			throw new IllegalArgumentException(
					"src_length must be in the range ]0, src.length-src_offset]");
		
		Mac hmac_alg = Mac.getInstance(MAC_ALG_HMAC_SHA1);
		hmac_alg.init(key);
		byte[] slice = Arrays.copyOfRange(src, src_offset, src_offset + src_length);
		byte [] reference =  hmac_alg.doFinal(slice);
		return Arrays.equals(reference, hmac);
		// -----END STUDENT CODE-----
	}

	/**
	 * Encrypts plain-text data using the AES block cipher in Counter with
	 * CBC-MAC (CCM) mode without encryption padding.
	 * 
	 * This method uses the AES block cipher in CCM mode, to encrypt a slice of
	 * the {@code plaintext} byte array. The JCE transformation name for this
	 * configuration is {@code AES/CCM/NoPadding}.
	 * 
	 * The bytes to be encrypted are specified by the {@code plaintext},
	 * {@code offset} and {@code length} parameters. The return value of this
	 * method is the encryption result of encrypting the selected plain-text
	 * bytes with AES.
	 * 
	 * @param plaintext
	 *            Byte array with the plain-text bytes to encrypt.
	 * 
	 * @param offset
	 *            Offset (index) of the first byte in the plain-text byte array
	 *            to encrypt.
	 * 
	 * @param length
	 *            Number of bytes to encrypt.
	 * 
	 * @param key
	 *            Secret key to be used for AES encryption. Since AES in CCM
	 *            mode requires the key to be 128 bit, this size is fixed.
	 * 
	 * @param iv
	 *            (Random) initialization vector required for the CCM mode. The
	 *            length of this byte array can vary between 9 and 13 bytes.
	 * 
	 * @return A new byte array containing the result of encrypting the
	 *         plain-text bytes defined by {@code plaintext}, {@code offset} and
	 *         {@code length} using the AES block cipher.
	 * 
	 * @throws InvalidKeyException
	 *             is thrown if the AES cipher does not accept the key given in
	 *             {@code key}. This error usually indicates a invalid key
	 *             length. Valid key length for AES in CCM mode is 128-bits.
	 * 
	 * @throws InvalidAlgorithmParameterException
	 *             is thrown if the parameters for the AES cipher are invalid.
	 *             This error usually indicates that the initial value given by
	 *             {@code iv} has the wrong length. The valid IV length for AES
	 *             is 9 to 13 bytes.
	 * 
	 * @throws NoSuchAlgorithmException
	 *             is thrown if the JCE provider does not recognize {@code AES}
	 *             as valid algorithm name of cipher. (Should not happen for
	 *             correctly installed IAIK JCE provider).
	 * 
	 * @throws NoSuchProviderException
	 *             is thrown if the JCE provider does not recognize the
	 *             {@code IAIK} JCE cryptography provider. (Should not happen
	 *             for correctly installed IAIK JCE provider).
	 * 
	 * @throws NoSuchPaddingException
	 *             is thrown if the JCE provider does not recognize
	 *             {@code NoPadding} as valid padding algorithm. (Should not
	 *             happen for correctly installed IAIK JCE provider)
	 * 
	 * @throws IllegalBlockSizeException
	 *             is thrown if the block size configured for the cipher is not
	 *             valid. (Should not happen for AES encryption)
	 * 
	 * @throws BadPaddingException
	 *             is thrown if the padding of the ciphertext block is not
	 *             valid. (Should not happen for encryption)
	 */
	public static byte[] aesCcmEncrypt(byte[] plaintext, int offset,
			int length, SecretKey key, byte[] iv) throws InvalidKeyException,
			InvalidAlgorithmParameterException, NoSuchAlgorithmException,
			NoSuchProviderException, NoSuchPaddingException,
			IllegalBlockSizeException, BadPaddingException {
		// TODO: Encrypt the plaintext with AES in CCM mode without padding.
		//
		// HINT: Use IvParameterSpec to pass the initialization value to the
		// cipher.

		// ----BEGIN STUDENT CODE----
		// Parameter checks
		//
		// System.out.println("plaintext length: " + plaintext.length);
		// System.out.println("offset:			" + offset);
		// System.out.println("length:			" + length);

		if (plaintext == null)
			throw new IllegalArgumentException("plaintext must not be null");
		if (key == null)
			throw new IllegalArgumentException("key must not be null");
		if (iv == null)
			throw new IllegalArgumentException("iv must not be null");
		if (offset < 0 || offset >= plaintext.length)
			throw new IllegalArgumentException(
					"offset must be in the range of [0, plaintext.length[");
		if (length <= 0 || length + offset > plaintext.length)
			throw new IllegalArgumentException(
					"lenght must be in the range ]0, plaintext.length-offset]");

		Cipher aes = Cipher.getInstance(ENC_ALG_AES_CCM_NOPADDING,
				IAIK_PROVIDER);

		IvParameterSpec spec = new IvParameterSpec(iv);

		aes.init(Cipher.ENCRYPT_MODE, key, spec);

		byte[] slice = Arrays.copyOfRange(plaintext, offset, offset + length);

		return aes.doFinal(slice);

		// ----END STUDENT CODE----
	}

	/**
	 * Randomly generates a secret key for symmetric algorithms.
	 * 
	 * This method uses the {@link KeyGenerator} class to produce a secret key
	 * which is compatible with the desired symmetric algorithm.
	 * 
	 * It is generally advisable to use {@link KeyGenerator#generateKey} for
	 * producing random keys, instead of producing the random key bytes by
	 * yourself. This way the the {@link KeyGenerator} implementation can check
	 * the generated random keys for known issues (eg. weak keys in case of the
	 * DES/3DES ciphers, ...)
	 * 
	 * 
	 * @param algorithm
	 *            Symmetric algorithm to be used with the key. This may be
	 *            {@code AES} for the AES block cipher or {@code HmacSHA1} for
	 *            the HMAC-SHA1 algorithm.
	 * 
	 * @param key_size
	 *            Bit-size of the key to be generated. In case of AES this can
	 *            be 128, 192 or 256.
	 * 
	 * @return The generate key.
	 * 
	 * @throws NoSuchProviderException
	 * @throws NoSuchAlgorithmException
	 */
	public static SecretKey generateSecretKey(String algorithm, int key_size)
			throws NoSuchAlgorithmException, NoSuchProviderException {
		KeyGenerator keygen = KeyGenerator
				.getInstance(algorithm, IAIK_PROVIDER);
		keygen.init(key_size, getSecureRandom());
		return keygen.generateKey();
	}

	/**
	 * Imports a secret key from a byte array and algorithm name.
	 * 
	 * This method uses the {@link SecretKeyFactory} class to produce a secret
	 * key which is compatible with the desired symmetric algorithm. The raw key
	 * material is provided in the {@value keydata} array.
	 * 
	 * Note that not all symmetric crypto primitives with a {@link KeyFactory}
	 * necessarily provide {@link SecretKeyFactory}. For example, some
	 * cryptography providers do not support {@link SecretKeyFactory}
	 * implementations for HMACs. This method tries to transparently handle
	 * absence of a {@link SecretKeyFactory} by returning an appropriate
	 * {@link SecretKeySpec} if necessary.
	 * 
	 * @param algorithm
	 *            Symmetric algorithm to be used with the key. This may be
	 *            {@code AES} for the AES block cipher or {@code HMAC/SHA1} for
	 *            the HMAC-SHA1 algorithm.
	 * 
	 * @param key_data
	 *            Raw key material for the secret key .
	 * 
	 * @return The generate key.
	 * 
	 * @throws NoSuchProviderException
	 * @throws InvalidKeySpecException
	 */
	public static SecretKey importSecretKey(String algorithm, byte[] key_data)
			throws NoSuchProviderException, InvalidKeySpecException {
		// Construct a secret key specification
		SecretKeySpec spec = new SecretKeySpec(key_data, algorithm);

		try {
			// Properly instantiate the secret key
			SecretKeyFactory keygen = SecretKeyFactory.getInstance(algorithm,
					IAIK_PROVIDER);
			return keygen.generateSecret(spec);

		} catch (NoSuchAlgorithmException e) {
			// This is a tricky case, we may ran into an algorithm which
			// provides a KeyGenerator but no SecretKeyFactory. This is for
			// example to case for HMAC algorithms on many crypto providers.
			//
			// We skip the translation of the key using a SecretKeyFactory and
			// directly return the SecretKeySpec (which by itself implements
			// SecretKey).
			// Note that this behavior may cause the corresponding
			// Cipher/Mac.init call to
			// fail due to an incompatible or invalid key ....
			return spec;
		}
	}

	/**
	 * Generates a new RSA key-pair.
	 * 
	 * @param modulus_size
	 *            Size of the modulus in bits.
	 * 
	 * @return The newly generated RSA key-pair. The public key can be retrieved
	 *         via {@link KeyPair#getPublic}, the private key is accessible as
	 *         {@link KeyPair#getPrivate}.
	 * 
	 * @throws NoSuchProviderException
	 * @throws NoSuchAlgorithmException
	 */
	public static KeyPair generateRsaKeyPair(int modulus_size)
			throws NoSuchAlgorithmException, NoSuchProviderException {

		KeyPairGenerator keygen = KeyPairGenerator.getInstance("RSA",
				IAIK_PROVIDER);

		keygen.initialize(modulus_size, getSecureRandom());
		return keygen.generateKeyPair();
	}

	/**
	 * Decrypts a cipher-text data using the AES block cipher in Counter with
	 * CBC-MAC (CCM) mode without encryption padding.
	 * 
	 * This method decrypts a cipher-text block which has been previously
	 * encrypted by the {@link CryptoToolBox#encrypt} method. It uses the AES
	 * block cipher in CCM mode to decrypt the ciphertext stored in a slice of
	 * the {@code ciphertext} byte array. The JCE transformation name for this
	 * configuration is {@code AES/CCM/NoPadding}.
	 * 
	 * The ciphertext to be decrypted is specified by the {@code ciphertext},
	 * {@code offset} and {@code length} parameters. The return value of this
	 * method is the plain-text obtained by decrypting the selected slice of the
	 * {@code ciphertext} byte array with AES.
	 * 
	 * Note that the ability to successfully decrypt a message does not say
	 * anything about the integrity and authenticity of the message. A secondary
	 * mechanism like an HMAC or a public key signature is needed if integrity
	 * and authenticity need to be protected.
	 * 
	 * 
	 * @param ciphertext
	 *            Byte array with the ciphertext-text bytes to encrypt.
	 * 
	 * @param offset
	 *            Offset (index) of the first byte of the cipher-text to be
	 *            decrypted.
	 * 
	 * @param length
	 *            Number of cipher-text bytes to decrypt.
	 * 
	 * @param key
	 *            Secret key to be used for AES decryption. The length of this
	 *            key depends on the AES variant to be used: For AES-128 a
	 *            16-byte key is needed, which is also required by CCM mode.
	 * 
	 * @param iv
	 *            Initialization vector required for the CCM mode. This byte
	 *            array must be the same initialization vector used during
	 *            encryption.
	 * 
	 * @return A new byte array containing the result of derypting the
	 *         cipher-text bytes specified by {@code ciphertext}, {@code offset}
	 *         and {@code length} using the AES block cipher.
	 * 
	 * @throws InvalidKeyException
	 *             is thrown if the AES cipher does not accept the key given in
	 *             {@code key}. This error usually indicates a invalid key
	 *             length. Valid key length for AES (CCM) is 128-bits.
	 * 
	 * @throws InvalidAlgorithmParameterException
	 *             is thrown if the parameters for the AES cipher are invalid.
	 *             This error usually indicates that the initial value given by
	 *             {@code iv} has the wrong length. The valid IV length for AES
	 *             are 9 to 13 bytes.
	 * 
	 * @throws NoSuchAlgorithmException
	 *             is thrown if the JCE provider does not recognize {@code AES}
	 *             as valid algorithm name of cipher. (Should not happen for
	 *             correctly installed IAIK JCE provider).
	 * 
	 * @throws NoSuchProviderException
	 *             is thrown if the JCE provider does not recognize the
	 *             {@code IAIK} JCE cryptography provider. (Should not happen
	 *             for correctly installed IAIK JCE provider).
	 * 
	 * @throws NoSuchPaddingException
	 *             is thrown if the JCE provider does not recognize
	 *             {@code NoPadding} as valid padding algorithm. (Should not
	 *             happen for correctly installed IAIK JCE provider)
	 * 
	 * @throws IllegalBlockSizeException
	 *             is thrown if the block size configured for the cipher is not
	 *             valid. (Should not happen for AES encryption)
	 * 
	 * @throws BadPaddingException
	 *             is thrown if the padding of the ciphertext block is not
	 *             valid. This may happen if the last cipher-text block which
	 *             contains the padding is corrupted.
	 */
	public static byte[] aesCcmDecrypt(byte[] ciphertext, int offset,
			int length, SecretKey key, byte[] iv) throws InvalidKeyException,
			InvalidAlgorithmParameterException, NoSuchAlgorithmException,
			NoSuchProviderException, NoSuchPaddingException,
			IllegalBlockSizeException, BadPaddingException {
		// TODO: Decrypt the ciphertext with AES in CCM mode without padding.
		//
		// HINT: Use IvParameterSpec to pass the initialization value to the
		// cipher.

		// ----BEGIN STUDENT CODE----
		// Parameter checks
		if (ciphertext == null)
			throw new IllegalArgumentException("ciphertext must not be null");
		if (key == null)
			throw new IllegalArgumentException("key must not be null");
		if (iv == null)
			throw new IllegalArgumentException("iv must not be null");
		if (offset < 0 || offset >= ciphertext.length)
			throw new IllegalArgumentException(
					"offset must be in the range of [0, ciphertext.length[");
		if (length <= 0 || length + offset > ciphertext.length)
			throw new IllegalArgumentException(
					"lenght must be in the range ]0, ciphertext.length-offset]");

		Cipher aes = Cipher.getInstance(ENC_ALG_AES_CCM_NOPADDING,
				IAIK_PROVIDER);

		IvParameterSpec spec = new IvParameterSpec(iv);

		aes.init(Cipher.DECRYPT_MODE, key, spec);

		byte[] slice = Arrays.copyOfRange(ciphertext, offset, offset + length);

		return aes.doFinal(slice);
		// ----END STUDENT CODE----
	}

	/**
	 * Encrypts (wraps) a secret key for transport over an untrusted channel, by
	 * using the RSA public key encryption.
	 * 
	 * This method encrypts (wraps) a secret key using an RSA public key. The
	 * resulting encrypted key packet can only be decrypted by the intended
	 * recipient, who owns the RSA private key corresponding to the RSA public
	 * key given in {@code public_key}.
	 * 
	 * @param key
	 *            The secret key to be encrypted for transmission over an
	 *            untrusted channel.
	 * 
	 * @param public_key
	 *            The RSA public key of the intended recipient. Only the owner
	 *            of the corresponding RSA private key will be able to decrypt
	 *            the key packet again.
	 * 
	 * @return An encrypted data packet containing the secret key. This data
	 *         packet can be sent over an untrusted channel, only the owner of
	 *         the correct RSA private key can decrypt it.
	 * 
	 * @throws InvalidKeyException
	 * @throws NoSuchPaddingException
	 * @throws NoSuchProviderException
	 * @throws NoSuchAlgorithmException
	 * @throws BadPaddingException
	 * @throws IllegalBlockSizeException
	 */
	public static byte[] wrapKey(SecretKey secret_key, PublicKey public_key)
			throws InvalidKeyException, NoSuchAlgorithmException,
			NoSuchProviderException, NoSuchPaddingException,
			IllegalBlockSizeException, BadPaddingException {
		// Basic sanity checks
		if (secret_key == null) {
			throw new IllegalArgumentException("Secret key must not be null.");
		} else if (public_key == null) {
			throw new IllegalArgumentException(
					"Recipient RSA public key must not be null.");
		}

		// TODO: Wrap the secret key using an RSA/ECB/PKCS1Padding cipher in key
		// wrapping
		// mode.
		//
		// HINT: The javax.crypto.Cipher#wrap method may be useful.
		byte[] wrapped_key;

		// ----BEGIN STUDENT CODE----
		Cipher cipher = Cipher.getInstance(ENC_ALG_RSA_ECB_PKCS1, IAIK_PROVIDER);
		cipher.init(Cipher.WRAP_MODE, public_key);
		wrapped_key = cipher.wrap(secret_key);
		// ----END STUDENT CODE----

		return wrapped_key;
	}

	/**
	 * Decrypts (unwraps) a secret key which was encrypted using the RSA public
	 * key encryption scheme.
	 * 
	 * This method decrypts (unwraps) a secret key which was encrypted by using
	 * an RSA public key.
	 * 
	 * @param wrapped
	 *            Byte array containing the RSA encrypted (wrapped) secret key,
	 *            which was produced by {@link CryptoToolBox#wrapKey}.
	 * 
	 * @param algorithm
	 *            The algorithm to be used with the decrypted secret key. This
	 *            value should be {@code AES} for an AES encryption key and
	 *            {@code HmacSHA1} for an HMAC key.
	 * 
	 * @param private_key
	 *            The RSA private key of the recipient. This private must match
	 *            the public key which had been originally used during
	 *            encryption.
	 * 
	 * @return The decrypted (unwrapped) secret key.
	 * 
	 * @throws InvalidKeyException
	 * @throws NoSuchPaddingException
	 * @throws NoSuchProviderException
	 * @throws NoSuchAlgorithmException
	 */
	public static SecretKey unWrapKey(byte[] wrapped, String algorithm,
			PrivateKey private_key) throws InvalidKeyException,
			NoSuchAlgorithmException, NoSuchProviderException,
			NoSuchPaddingException {
		// Basic sanity checks
		if (wrapped == null) {
			throw new IllegalArgumentException(
					"Wrapped secret key blob must not be null.");
		} else if (algorithm == null) {
			throw new IllegalArgumentException("Algorithm must not be null.");
		} else if (private_key == null) {
			throw new IllegalArgumentException(
					"Recipient RSA private key must not be null.");
		}

		// TODO: Wrap the secret key using an RSA/ECB/PKCS1Padding cipher in key
		// wrapping mode.
		//
		// HINT: The javax.crypto.Cipher#unwrap method may be useful.
		SecretKey secret_key;

		// ----BEGIN STUDENT CODE----
		Cipher cipher = Cipher.getInstance(ENC_ALG_RSA_ECB_PKCS1, IAIK_PROVIDER);
		cipher.init(Cipher.UNWRAP_MODE, private_key);
		secret_key = (SecretKey) cipher.unwrap(wrapped, algorithm, Cipher.SECRET_KEY);
		// ----END STUDENT CODE----

		return secret_key;
	}

	/**
	 * Signs a data-blob using an RSA private key.
	 * 
	 * This method first constructs an RSA signature (with SHA1 as message
	 * digest, algorithm {@code SHA1withRSA}) of the data-blob and then packs
	 * the signature and the data into a new byte array, which is returned as
	 * result from this method.
	 * 
	 * @param blob
	 *            The data blob to be signed.
	 * 
	 * @param sigkey
	 *            RSA private key to use for signing.
	 * 
	 * @return The data blob and its signature packed into a single byte array.
	 * 
	 * @throws NoSuchProviderException
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeyException
	 * @throws SignatureException
	 */
	public static byte[] packAndSignBlob(byte[] blob, PrivateKey sigkey)
			throws NoSuchAlgorithmException, NoSuchProviderException,
			InvalidKeyException, SignatureException {
		// Basic sanity checks
		if (blob == null) {
			throw new IllegalArgumentException("Data blob not be null.");
		} else if (sigkey == null) {
			throw new IllegalArgumentException(
					"Signer RSA private key must not be null.");
		}

		// TODO: Sign the blob with the RSA algorithm, using SHA1 as message
		// digest. Store
		// the signature value in the sig_bytes array.
		//
		// HINT: java.security.Signature will be useful ...
		byte[] sig_bytes;

		// ----BEGIN STUDENT CODE----
		Signature signer = Signature.getInstance(SIG_ALG_RSA_SIG_SHA1, IAIK_PROVIDER);
		signer.initSign(sigkey);
		signer.update(blob);
		sig_bytes = signer.sign();	
		// ----END STUDENT CODE----

		// Sanity check: We only have 2 bytes for the length prefix below.
		int sig_len = sig_bytes.length;
		if (sig_len > 65535) {
			throw new SignatureException(
					"Unsupported signature block length (huh?)");
		}

		// Assemble and return the signature + data-blob combination.
		byte[] result = new byte[2 + sig_bytes.length + blob.length];

		// Store the length of the signature
		result[0] = (byte) ((sig_len >> 8) & 0x00FF); // MSB of length
		result[1] = (byte) (sig_len & 0x00FF); // LSB of length

		// Signature block
		System.arraycopy(sig_bytes, 0, result, 2, sig_bytes.length);

		// Data blob
		System.arraycopy(blob, 0, result, 2 + sig_bytes.length, blob.length);

		return result;
	}

	/**
	 * Verifies the RSA signature on a data-blob and unpacks the payload.
	 * 
	 * This method first extracts the signature value and the data payload from
	 * the signed blob. It then verifies the RSA signature on the data part. In
	 * case of successful verification the data part is returned. In case of a
	 * verification error, due to a data-integrity problem an appropriate
	 * exception is thrown.
	 * 
	 * @param signed_blob
	 *            The signed blob to be verified and unpacked.
	 * 
	 * @param pubkey
	 *            RSA public key to use for verification.
	 * 
	 * @return The data part of the signed blob. This method only returns
	 *         normally if signature verification succeeds.
	 * 
	 * 
	 * @throws NoSuchProviderException
	 * @throws NoSuchAlgorithmException
	 * @throws InvalidKeyException
	 * @throws SignatureException
	 */
	public static byte[] verifyBlobAndUnpack(byte[] signed_blob,
			PublicKey pubkey) throws NoSuchAlgorithmException,
			NoSuchProviderException, InvalidKeyException, SignatureException {
		// Basic sanity checks
		if (signed_blob == null) {
			throw new IllegalArgumentException("Signed data blob not be null.");
		} else if (signed_blob.length < 2) {
			throw new IllegalArgumentException(
					"Length of signed data blob must be larger or equal than 2.");
		} else if (pubkey == null) {
			throw new IllegalArgumentException(
					"RSA public key must not be null.");
		}

		// Extract the data-part and the signature part
		int sig_len = ((signed_blob[0] & 0x00FF) << 8)
				| (signed_blob[1] & 0x00FF);
		byte[] sig_bytes = dupBytes(signed_blob, 2, sig_len);
		byte[] data_bytes = dupBytes(signed_blob, 2 + sig_len,
				signed_blob.length - 2 - sig_len);

		// TODO: Verify the signature (sig_bytes) on the data part (data_bytes)
		// with the RSA algorithm, using SHA1 as message digest. Set the
		// "verified" variable to true if verification succeeds or to false if
		// verification
		// fails.
		//
		// HINT: java.security.Signature will be useful ...

		boolean verified;

		// ----BEGIN STUDENT CODE----
		Signature signer = Signature.getInstance(SIG_ALG_RSA_SIG_SHA1, IAIK_PROVIDER);
		signer.initVerify(pubkey);
//		signer.update(signed_blob);
		verified = signer.verify(signed_blob);
		// ----END STUDENT CODE----

		if (!verified) {
			throw new SignatureException("Signature verification failed.");
		}

		// Return the data bytes
		return data_bytes;
	}
}
