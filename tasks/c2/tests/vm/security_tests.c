/*
 * security_tests.c
 *
 *  Created on: 15.01.2014
 *      Author: sase
 */

#include "tests.h"

//----------------------------------------------------------------------
typedef struct TestSimpleAppData {
  /// \brief Input data (for VM_READ)
  const unsigned char *input;

  /// \brief Input data length (for VM_READ)
  size_t input_len;

  /// \brief Expected output data (for VM_WRITE)
  const unsigned char *output;

  /// \brief Expected output data length (for VM_READ)
  size_t output_len;

  /// \brief Checks if output still matches
  bool output_matches;
} TestSimpleAppData;

//----------------------------------------------------------------------
static int TestSimpleIoRead(VmContext *vm)
{
  TestSimpleAppData *app = VmGetAppData(vm);
  if (!app) {
    CU_FAIL_FATAL("VmGetAppData is not working");
  }

  // Assume end of input
  int ret = -2;
  if (app->input_len > 0) {
    ret = *app->input;
    app->input += 1;
    app->input_len -= 1;
  }

  return ret;
}

//----------------------------------------------------------------------
static bool TestSimpleIoWrite(VmContext *vm, unsigned char c)
{
  TestSimpleAppData *app = VmGetAppData(vm);
  if (!app) {
    CU_FAIL_FATAL("VmGetAppData is not working");
  }

  // Detect an output mismatch (only report the first one)
  if (app->output_matches) {
    if (app->output_len == 0) {
      // No more output expected
      CU_FAIL("unexpected extra output produced by bytecode program");
      app->output_matches = false;

    } else {
      // No mismatch found yet, compare this
      if (*app->output++ != c) {
        CU_FAIL("bytecode program output does not match expected output");
        app->output_matches = false;
      }

      app->output_len -= 1;
    }
  }

  // We can sink any number of characters
  return true;
}

//----------------------------------------------------------------------
int TestExecSimple1(const void *program, size_t program_length, size_t max_stack,
                   const void *input, size_t input_len,
                   const void *output, size_t output_len)
{
  // Setup our context data
  TestSimpleAppData testdata = {
    .input      = input,
    .input_len  = input_len,
    .output     = output,
    .output_len = output_len,
    .output_matches = true,
  };

  // Populate a temporary buffer with the resource data, then load
  Buffer *bytecode = BufferCreate();
  CU_ASSERT_PTR_NOT_NULL_FATAL(bytecode);
  CU_ASSERT_TRUE_FATAL(BufferAppend(bytecode, program, program_length));

  // Create a VM and load the bytecode
  VmContext *vm = VmCreate(max_stack, &testdata,
                           TestSimpleIoRead,
                           TestSimpleIoWrite);
  CU_ASSERT_PTR_NOT_NULL_FATAL(vm);
  CU_ASSERT_TRUE_FATAL(VmLoadByteCode(vm, bytecode));

  // Discard the input buffer
  BufferFree(bytecode);

  // Main execute loop
  int ret;
  do {
    ret = VmStep(vm);
  } while (ret == 0);

  // Input must have been consumed (fully)
  CU_ASSERT(testdata.input_len == 0);

  // Output must match (fully)
  CU_ASSERT(testdata.output_matches && testdata.output_len == 0);

  // Destroy the VM
  VmDelete(vm);

  // Return the exec result
  return ret;
}

//----------------------------------------------------------------------
void TestVmExecUdivBy0LittleEndian(void)
{
	unsigned char data[] = {
	    /* programm tries to do an udiv by 0 */
			0x00, 0x6d, 0x76, 0x74, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
			0x00, 0x6a, 0x62, 0x6f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xc0, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0a,
			0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x54, 0x60, 0x00,
			0x04, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x17, 0x00, 0x64, 0x6e,
			0x65 };

	  CU_ASSERT(-1 == TestExecSimple1(data, 57, 256,
	                                NULL, 0,
	                                NULL, 0));
}

//----------------------------------------------------------------------
void TestVmExecSdivBy0LittleEndian(void)
{
	unsigned char data[] = {
			/* programm tries to do an sdiv by 0 */
	0x00, 0x6d, 0x76, 0x74, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
			0x00, 0x6a, 0x62, 0x6f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xc0, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xf6,
			0xff, 0xff, 0xff, 0x04, 0x00, 0x00, 0x00, 0x00, 0x55, 0x60, 0x00,
			0x04, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x17, 0x00, 0x64, 0x6e,
			0x65 };

	  CU_ASSERT(-1 == TestExecSimple1(data, 57, 256,
	                                NULL, 0,
	                                NULL, 0));
}

//----------------------------------------------------------------------
void TestVmExecSdivOverflowLittleEndian(void)
{
	unsigned char data[] = {
	    /* bin/hello.bin.be */
	0x00, 0x6d, 0x76, 0x74, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
			0x00, 0x6a, 0x62, 0x6f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xc0, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
			0x00, 0x00, 0x80, 0x04, 0xff, 0xff, 0xff, 0xff, 0x55, 0x60, 0x00,
			0x04, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x17, 0x00, 0x64, 0x6e,
			0x65 };

	  CU_ASSERT(-1 == TestExecSimple1(data, 57, 256,
	                                NULL, 0,
	                                NULL, 0));
}

//----------------------------------------------------------------------
void TestVmExecMJmpLittleEndian(void)
{
	unsigned char data[] = {
	    /* bin/hello.bin.be */
	0x00, 0x6d, 0x76, 0x74, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
			0x00, 0x6a, 0x62, 0x6f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xc0, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x01,
			0x80, 0x60, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x17,
			0x00, 0x64, 0x6e, 0x65 };

	  CU_ASSERT(-1 == TestExecSimple1(data, 49, 256,
	                                NULL, 0,
	                                NULL, 0));
}

//----------------------------------------------------------------------
void TestVmExecAProtLittleEndian(void)
{
	unsigned char data[] = {
	    /* bin/hello.bin.be */
	0x00, 0x6d, 0x76, 0x74, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
			0x00, 0x6a, 0x62, 0x6f, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xda, 0x0e, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20,
			0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x0a, 0x00, 0x00, 0x6a, 0x62,
			0x6f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3b, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00,
			0x41, 0x00, 0x40, 0x00, 0x05, 0x00, 0x00, 0x00, 0xda, 0x44, 0x41,
			0x01, 0x40, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x15, 0x13,
			0x00, 0x40, 0x01, 0x60, 0x03, 0x40, 0x00, 0x04, 0x01, 0x00, 0x00,
			0x00, 0x50, 0x41, 0x00, 0x12, 0xdc, 0xff, 0x60, 0x00, 0x04, 0x00,
			0x00, 0x00, 0x00, 0x60, 0x01, 0x17, 0x00, 0x64, 0x6e, 0x65 };

	  CU_ASSERT(-1 == TestExecSimple1(data, 121, 256,
	                                NULL, 0,
	                                NULL, 0));
}

//----------------------------------------------------------------------
void TestVmExecW2ROVarLittleEndian(void)
{
	unsigned char data[] = {
	    /* bin/hello.bin.be */
	0x00, 0x6d, 0x76, 0x74, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
			0x00, 0x6a, 0x62, 0x6f, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xda, 0x0e, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20,
			0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x0a, 0x00, 0x00, 0x6a, 0x62,
			0x6f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x8b, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x48, 0x00, 0x00, 0x00,
			0x04, 0x06, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xda, 0x45,
			0x04, 0x65, 0x00, 0x00, 0x00, 0x04, 0x07, 0x00, 0x00, 0x00, 0x05,
			0x00, 0x00, 0x00, 0xda, 0x45, 0x04, 0x6c, 0x00, 0x00, 0x00, 0x04,
			0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xda, 0x45, 0x04,
			0x6c, 0x00, 0x00, 0x00, 0x04, 0x09, 0x00, 0x00, 0x00, 0x05, 0x00,
			0x00, 0x00, 0xda, 0x45, 0x04, 0x6f, 0x00, 0x00, 0x00, 0x04, 0x0a,
			0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xda, 0x45, 0x04, 0x00,
			0x00, 0x00, 0x00, 0x41, 0x00, 0x40, 0x00, 0x05, 0x00, 0x00, 0x00,
			0xda, 0x44, 0x41, 0x01, 0x40, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00,
			0x2e, 0x15, 0x13, 0x00, 0x40, 0x01, 0x60, 0x03, 0x40, 0x00, 0x04,
			0x01, 0x00, 0x00, 0x00, 0x50, 0x41, 0x00, 0x12, 0xdc, 0xff, 0x60,
			0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x17, 0x00, 0x64,
			0x6e, 0x65 };

	  CU_ASSERT(-1 == TestExecSimple1(data, 201, 256,
	                                NULL, 0,
	                                NULL, 0));
}
