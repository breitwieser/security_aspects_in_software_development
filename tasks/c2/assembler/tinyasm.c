///
/// \file
/// \brief Standalone main program for the tinyvm assembler.
///
#include "assembler_imp.h"

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

#ifndef NDEBUG
extern void AsmLemonParseTrace(FILE *TraceFILE, char *zTracePrompt);
#endif

//----------------------------------------------------------------------
typedef struct AsmCmdLineInfo {
  /// \brief Name of the output file.
  const char *outputFileName;

  /// \brief Name of the input file.
  const char *inputFileName;

  /// \brief Verbosity of the assembler output.
  AsmVerbosityLevel verbosity;

  /// \brief Byte endianess of the generated bytecode.
  bool isBigEndian;
} AsmCmdLineInfo;

//----------------------------------------------------------------------
static char* AsmMainGetProgName(char *argv0)
{
  // Start with a sane default
  char *progname = "tinyasm";

  if (argv0) {
    // Find the last slash or backslash character (for printout only)
    char *pathsep = NULL;
    char *pos = argv0;
    while (*pos != '\0') {
      if (*pos == '/' || *pos == '\\') {
	pathsep = pos;
      }
      pos += 1;
    }

    char *basename = pathsep ? (pathsep + 1) : argv0;
    if (*basename != '\0') {
      progname = basename;
    }
  }

  // And return the program name
  return progname;
}

//----------------------------------------------------------------------
static void AsmMainShowUsage(const char *progname)
{
  static const char HELP_TEXT[] =
    "TinyVM Bytecode Assembler (vm bytecode format: v%u.%u)\n"
    "======================================================================\n"
    "Usage: %s [-o <outfile>] [-l] [-b] [<infile>]\n\n"
    "-o <outfile>        - Write binary bytecode output to file '<outfile>'\n"
    "                      (default: do not write a binary file)\n"
    "-b                  - Assemble for big-endian bytecode format (default)\n"
    "-l                  - Assemble for little-endian bytecode format (experimental)\n"
    "-v                  - Verbose mode (show errors and verbose information)\n"
    "-q                  - Quiet mode (minimal log output)\n"
#ifndef NDEBUG
    "-t                  - Trace the lemon parser to standard output\n"
#endif
    "[<infile>]          - Read source code from input file '<infile>'\n"
    "                      (default: standard input)\n";

  // And print the help text
  fprintf(stdout, HELP_TEXT, VM_VERSION_MAJOR, VM_VERSION_MINOR, progname);
}

//----------------------------------------------------------------------
static bool AsmMainParseCmdLine(AsmCmdLineInfo *info, int argc, char **argv)
{
  if (!info || argc < 1 || !argv) {
    return false; // Bad parameters
  }

  // Strip any leading relative or absolute path names from argv[0]
  // (we just show the last path component; argv[0] is overidden, to get
  // consistent results with getopt)
  argv[0] = AsmMainGetProgName(argv[0]);

  // Default setup
  info->outputFileName = NULL;
  info->inputFileName = NULL;

#ifdef VM_BIGENDIAN
  info->isBigEndian = true;
#else
  info->isBigEndian = false;
#endif

  // Default: Show errors  (but hide verbose information)
  info->verbosity = ASM_VERBOSITY_ERROR;

  // Parse the command line (using getopt)
  int c;

  while ((c = getopt(argc, argv, "ho:lbvqt")) != -1) {
    switch (c) {
    case 'h':
      AsmMainShowUsage(argv[0]);
      return false;

    case 'o':
      info->outputFileName = optarg;
      break;

    case 'l':
      info->isBigEndian = false;
      break;

    case 'b':
      info->isBigEndian = true;
      break;

    case 'v':
      info->verbosity = ASM_VERBOSITY_INFO;
      break;

    case 'q':
      info->verbosity = ASM_VERBOSITY_QUIET;
      break;

    case 't':
#ifndef NDEBUG
      AsmLemonParseTrace(stdout, "trace: lemon: ");
      break;
#else
      AsmError(NULL, NULL, "tracing of the lemon parser is only supported "
	       "in debug builds.");
      return false;
#endif


    default:
      AsmError(NULL, NULL, "unsupported command line options (see '%s -h' "
	       "for supported options)", argv[0]);
      return false;
    }
  }

  // Input file follows at the end
  if (optind < argc) {
    size_t num_infiles = argc - optind;
    if (num_infiles != 1) {
      AsmError(NULL, NULL, "unsupported number of source files.");
      return false;
    }

    info->inputFileName = argv[optind];
  }

  return true;
}

//----------------------------------------------------------------------
static AsmLexer* AsmMainOpenLexer(Assembler *assembler, const char *input_file_name)
{
  AsmLexer *lexer = NULL;
  assert (assembler != NULL);


  if (input_file_name) {
    // Try to open the input file
    FILE *infile = fopen(input_file_name, "rt");

    // And create the lexer (NOTE: AsmLexerFromFile takes care of releasing
    // infile in case of errors)
    lexer = AsmLexerFromFile(infile, true);
    if (!lexer) {
      AsmError(assembler, NULL, "failed to create a lexer for input file '%s'",
	       input_file_name);
    } else {
      AsmInfo(assembler, NULL, "created a lexer for input file '%s'",
	      input_file_name);
    }

  } else {
    // Use standard input (NOTE: Do not pass stream ownership of standard input)
    lexer = AsmLexerFromFile(stdin, false);
    if (!lexer) {
      AsmError(assembler, NULL, "failed to create a lexer for the standard input stream.");
    } else {
      AsmInfo(assembler, NULL, "created a lexer for the standard input stream.");
    }
  }

  return lexer;
}

//----------------------------------------------------------------------
static bool AsmWriteBinaryFileCallback(void *p_file, const void *data,
				       size_t len)
{
  if (!p_file) {
    return false;
  }

  return fwrite(data, len, 1, p_file) == 1;
}

//----------------------------------------------------------------------
static bool AsmMainWriteOutputFile(Assembler *assembler,
				   const char *output_file_name)
{
  assert (assembler != NULL);
  assert (output_file_name != NULL);

  bool success = true;
  FILE *outfile = fopen(output_file_name, "wb");

  if (!outfile) {
    AsmError(assembler, NULL, "failed to open output file '%s'",
	     output_file_name);
    success = false;
  }

  if (success) {
    success = AsmWriteOutput(assembler, AsmWriteBinaryFileCallback, outfile);
    if (fclose(outfile) != 0) {
      // NOTE: A failing call to fclose typically indicates problems with writing
      //  the FILE stream's buffer back to disk ...
      success = false;
    }

    if (success) {
      AsmInfo(assembler, NULL, "program unit was written successfully to '%s'.",
	      output_file_name);
    } else {
      AsmError(assembler, NULL, "failed to write the program unit to output file '%s'",
	       output_file_name);
    }
  }

  return success;
}


//----------------------------------------------------------------------
/// \brief Main entry point for the standalone assembler tool.
///
/// \return \c EXIT_SUCCESS if the assembler completed successfully.
/// \return \c EXIT_FAILURE if the assembler failed with errors.
int main(int argc, char **argv)
{
  AsmCmdLineInfo info;
  Assembler *assembler = NULL;
  AsmLexer *lexer = NULL;
  bool success = true;

  // Command line options
  if (!AsmMainParseCmdLine(&info, argc, argv)) {
    return EXIT_FAILURE;
  }

  // Create the assembler
  assembler = AsmNew(info.verbosity, info.isBigEndian);
  if (!assembler) {
    AsmError(NULL, NULL, "failed to create the assembler");
    success = false;

  } else {
    AsmInfo(assembler, NULL, "assembling in %s bytecode format",
	    info.isBigEndian ? "big-endian" : "(experimental) little-endian");
  }

  // Create the lexer
  if (success) {
    lexer = AsmMainOpenLexer(assembler, info.inputFileName);
  }

  // Parse the input
  if (success) {
    success = AsmParse(assembler, lexer);
    if (success) {
      AsmInfo(assembler, NULL, "parsind phase completed");
    } else {
      AsmError(assembler, NULL, "parsing phase failed");
    }

    // Cleanup the lexer
    AsmLexerDelete(lexer);
    lexer = NULL;
  }

  // Link the parsed obejcts
  if (success) {
    success = AsmLink(assembler);
    if (success) {
      AsmInfo(assembler, NULL, "linking phase completed");
    } else {
      AsmError(assembler, NULL, "linking phase failed");
    }
  }

  // Write the binary output file
  if (success && info.outputFileName != NULL) {
    success = AsmMainWriteOutputFile(assembler, info.outputFileName);
  }

  // Report final status
  if (success) {
    AsmInfo(assembler, NULL, "assembler completed without errors");
  } else {
    unsigned errors = AsmGetErrorCount(assembler);
    AsmError(assembler, NULL, "assembler failed with %u error(s)", errors);
  }

  // Final cleanup
  AsmDelete(assembler);

  return success ? EXIT_SUCCESS : EXIT_FAILURE;
}
