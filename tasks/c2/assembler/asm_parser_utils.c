///
/// \file
/// \brief Utilitiy function for the parser
///
#include "assembler_imp.h"
#include "grammar.h"

#include <stdlib.h>
#include <errno.h>

//----------------------------------------------------------------------
// Lemon generater parser API
//
// This functions are generated by the Lemon parser generator from
// the grammar given in \c grammar.y, see the auto-generated \c grammar.c
// file for the implementation.

void* AsmLemonParseAlloc(void* (*mallocProc)(size_t));
void AsmLemonParseFree(void *lemon, void (*freeProc)(void*));
void AsmLemonParse(void *lemon, int major, AsmToken *minor,
		   Assembler *assembler);

//----------------------------------------------------------------------
bool AsmParse(Assembler *assembler, AsmLexer *lexer)
{
  if (!assembler) {
    return false; // Invalid arguments
  }

  if (assembler->errors) {
    return false; // Refuse to parse when there were errors.
  }

  // Allocate the lemon parser
  void *lemon = AsmLemonParseAlloc(&malloc);
  if (!lemon) {
    return false; // Out of memory
  }

  // Main parsing loop
  bool end_of_input = false;
  do {
    // Fetch next token from the lexer
    AsmToken *token = NULL;

    int ret = AsmLexerScan(&token, lexer);
    if (ret == ASM_LEXER_ERROR) {
      // Lexical scanner error (stop)
      assert (token == NULL);
      AsmError(assembler, NULL, "Lexical scanner error near line %u, column %u. Giving up!",
	       AsmLexerGetLine(lexer), AsmLexerGetColumn(lexer));

    } else if (ret == ASM_LEXER_EOF) {
      // Lexical scanner reached end of input
      assert (token == NULL);
      end_of_input = true;

    } else {
      // Lexical scanner produced a new token
      assert (ret == ASM_LEXER_SUCCESS);
      assert (token != NULL);
    }

    // Delegate to the lemon parser
    AsmLemonParse(lemon, AsmTokenGetType(token), token, assembler);

  } while (!assembler->errors && !end_of_input);

  // Dispose the lemon parser
  AsmLemonParseFree(lemon, &free);
  return !assembler->errors;
}

//----------------------------------------------------------------------
AsmCodeBuffer* AsmUtilNewCodeBuffer(Assembler *assembler, AsmToken *hint)
{
  AsmCodeBuffer *code = AsmCodeNew(assembler->isBigEndian);
  if (!code) {
    AsmError(assembler, hint, "failed to create a new code buffer.");
  }


  return code;
}

//----------------------------------------------------------------------
AsmCodeBuffer* AsmUtilAppendCodeBytes(Assembler *assembler, AsmToken *hint,
				      AsmCodeBuffer *code,
				      const void *bytes, size_t len)
{
  if (!code) {
    return NULL;
  }

  // Try to append the byte
  AsmBuffer *data = AsmCodeGetBytes(code);
  if (!AsmBufferAppend(data, bytes, len)) {
    AsmError(assembler, hint, "failed to append bytes to code buffer. (out of memory?)");
  }

  return code;
}

//----------------------------------------------------------------------
AsmCodeBuffer* AsmUtilAppendCodeWord(Assembler *assembler, AsmToken *hint,
				     AsmCodeBuffer *code, uint32_t word)
{
  if (!code) {
    return NULL;
  }

  // Try to append the byte
  AsmBuffer *data = AsmCodeGetBytes(code);
  if (!AsmBufferAppendWord(data, word)) {
    AsmError(assembler, hint, "failed to append word to code buffer. (out of memory?)");
  }

  return code;
}

//----------------------------------------------------------------------
AsmCodeBuffer* AsmUtilAppendCodeByte(Assembler *assembler, AsmToken *hint,
				     AsmCodeBuffer *code, uint8_t byte)
{
  return AsmUtilAppendCodeBytes(assembler, hint, code, &byte, 1);
}

//----------------------------------------------------------------------
AsmCodeBuffer* AsmUtilSkipCodeBytes(Assembler *assembler, AsmToken *hint,
				    AsmCodeBuffer *code, unsigned char value, size_t len)
{
  if (!code) {
    return NULL;
  }

  // Try to fill the requested number of bytes
  AsmBuffer *data = AsmCodeGetBytes(code);
  if (!AsmBufferSkip(data, value, len)) {
    AsmError(assembler, hint, "failed to append bytes to buffer. (out of memory?)");
  }

  return code;
}

//----------------------------------------------------------------------
AsmCodeBuffer* AsmUtilAppendImm32(Assembler *assembler, AsmToken *hint,
				  AsmCodeBuffer *code, int64_t value)
{
  // Range checks
  bool in_range = (INT32_MIN <= value && value <= UINT32_MAX);
  if (!in_range) {
    AsmError(assembler, hint, "value %d exceeds limits of 32-bit integers",
	     (int) value);
  }

  // And emit
  uint32_t imm = (uint32_t) (value & 0xFFFFFFFFU);
  uint8_t opc[] = {
    VM_OP_IMM32,
    ASM_INIT_WORD(imm, AsmCodeIsBigEndian(code))
  };

  return AsmUtilAppendCodeBytes(assembler, hint, code, opc, sizeof(opc));
}

//----------------------------------------------------------------------
AsmCodeBuffer* AsmUtilMergeCode(Assembler *assembler, AsmToken *hint,
				AsmCodeBuffer *head, AsmCodeBuffer *tail)
{
  // Return the tail buffer if we do not have a head yet
  if (head == NULL) {
    return tail;
  }

  assert (tail != NULL);

  if (!AsmCodeMerge(head, tail)) {
    AsmError(assembler, hint, "failed to merge code buffers.");
  }

  // Dispose the tail buffer, return the read buffer
  AsmCodeDelete(tail);
  return head;
}

//----------------------------------------------------------------------
int64_t AsmUtilParseInteger(Assembler *assembler, AsmToken *token,
			    int64_t min_value, int64_t max_value)
{
  int64_t value = 0;


  if (token) {
    // Clear errno (see strtoll manpage)
    errno = 0;

    // Parse as 64-bit integer
    char *endp = NULL;
    value = strtoll(AsmTokenGetText(token), &endp, 0);
    assert(endp != NULL);

    if (*endp != '\0' || errno != 0) {
      AsmError(assembler, token, "unparsable integer value.");
      value = 0;
    }

    // Range check
    if (value < min_value || value > max_value) {
      AsmError(assembler, token, "large integer constant %lld exceeds allowed range. (%lld to %lld)",
	       (long long) value, (long long) min_value, (long long) max_value);
      value = 0;
    }
  }

  return value;
}

//----------------------------------------------------------------------
AsmCodeBuffer* AsmUtilDeclareVariables(Assembler *assembler,
				       AsmCodeBuffer *code,
				       AsmVariable *vars)
{
  if (!code) {
    AsmVariablesDeleteChain(vars); // Dispose (we can't merge)
    return NULL;
  }

  AsmVariable *current = vars;

  while (current != NULL) {
    // Split the current variable
    AsmVariable *tail = AsmVariablesSplit(current);
    const AsmToken *hint = AsmVariableGetToken(current);
    const char *name = AsmVariableGetName(current);

    // Check for duplicates
    AsmVariable *duplicate = AsmCodeLookupVariable(code, name);
    if (duplicate != NULL) {
      const AsmToken *first_decl = AsmVariableGetToken(duplicate);

      AsmError(assembler, hint, "multiple declarations of local variable '%s' "
	       "(first declaration is in line %u, column %u)", name,
	       AsmTokenGetLine(first_decl), AsmTokenGetColumn(first_decl));
      AsmVariableDelete(current);

    } else if (!AsmCodeAddVariables(code, current)) {
      AsmError(assembler, hint, "internal error: failed to add local variable '%s'",
	       name);
      AsmVariableDelete(current);

    }

    current = tail;
  }


  return code;
}

//----------------------------------------------------------------------
bool AsmUtilDefineObject(Assembler *assembler, AsmToken *name,
			 VmQualifiers qualifiers, AsmCodeBuffer *content,
			 uint32_t handle)
{
  bool success = true;

  if (!assembler || !name || !content) {
    success = false; // Bad arguments (likely an earlier parser error)
  }

  const char *objname = AsmTokenGetText(name);

  // Create the object (on succes ownership of "name" and "content" is
  // transferred to the new object)
  AsmObject *object = NULL;
  if (success) {
    object = AsmObjectNew(name, qualifiers, content);
    if (!object) {
      AsmError(assembler, name, "internal error: failed to create object '%s'.",
	       objname);
      success = false;
    }

    // "name" and "content" are now owned by the object
    name = NULL;
    content = NULL;
  }

  // Add the object (errors are reported by AsmAddObjects)
  if (success) {
    if (handle != VM_NULL_HANDLE) {
      AsmObjectSetHandle(object, handle);
    }

    success = AsmAddObjects(assembler, object);
  }


  if (success) {
    // Successfully created an object
    AsmInfo(assembler, name, "created %s object '%s'",
	    (qualifiers & VM_QUALIFIER_CODE)? "code" : "data",
	    objname);
    return true;

  } else {
    // Failed to create an object, cleanup remainings
    AsmObjectDelete(object);
    AsmTokenDelete(name);
    AsmCodeDelete(content);
    return false;
  }
}
