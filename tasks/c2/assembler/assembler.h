///
/// \file
/// \brief Publicly visible parts of the tinyasm assembler.
///
/// \warning This file defines the publicly visible API of the tinyasm
///  assembler. It as part of the assignment specification and must not
///  be changed without explicit permission. See the \c assembler_imp.h
///  header file for implementation details.
///
#ifndef TINYVM_ASSEMBLER_PUBLIC_H
#define TINYVM_ASSEMBLER_PUBLIC_H 1

// Utilitiy functions
#include "util/buffer.h"

// Virtual machine bytecode definitions
#include "vm/bytecodes.h"

// Additional headers
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdio.h>

//----------------------------------------------------------------------
// Keyword handling
//
/// \cond SKELETON_CODE

/// \brief Static keyword information structure
///
/// This data structure represents information about keywords and
/// their associated token codes.
///
/// \see AsmKeywordLookup for more details.
typedef struct AsmKeywordInfo {
  /// \brief Name (text) of this keyword
  const char *name;

  /// \brief Token code of the corresponding assembler token.
  int tokenType;
} AsmKeywordInfo;

/// \brief Finds the keyword information for a given string.
///
/// This function tries to find a \ref AsmKeywordInfo structure
/// for the string given by \c keyword and \c len. If the string
/// is a valid keyword recognized by the assembler, a non-NULL object
/// will be returned.
///
/// \param[in] keyword The keyword string to be looked up. This
///   parameter does not need to be NUL terminated. The function will use
///   \c strncmp together with the supplied \c len parameter for any
///   string comparisons.
///
/// \param len Length of the \c keyword string.
///
/// \return A pointer to valid \ref AsmKeywordInfo structure, if the given
///   string is a builtin keyword of the tinyasm assembler.
///
/// \return NULL if the given string is not a built-in keyword of the
///   tinyasm assembler. (Lexical scanners would typically interpret
///   this result as the string being an identifier).
const AsmKeywordInfo* AsmKeywordLookup(const char *keyword, size_t len);

/// \endcond
//----------------------------------------------------------------------
/// \defgroup AsmTokens Lexical token handling
/// @{

/// \brief A token produced by the lexical scanner.
///
/// The lexical scanner (in particular the \ref AsmLexerScan) function
/// analyses the input stream and produces tokens for each relevant
/// fragment. The parser then consumes the tokens to parse the assembler
/// syntax, and ultimately to assemble the output bytecode program.
///
/// Each token contains:
/// \li A token code (such as ASM_TOKEN_INT) to tell the parser about
///   the nature of the input fragment.
///
/// \li The textual value of the token.
///
/// \li Line and column number information about the source code location
///  of the token.
typedef struct AsmToken AsmToken;

/// \brief Creates a new token.
///
/// This function creates a new token using the information provided
/// in the parameters.
///
/// \param type is the token (type) code. Valid token type codes can
///   be found in the \c grammar.h file, which is generated by the
///   lemon parser generator.
///
///   This parameter is not validated by the function and will be accepted
///   as is. (We rely on the generated parser's error handling capabilities
///   to deal with invalid token codes, for simplicity.)
///
/// \param line is the source line number of this token (or zero if
///   the source line is not known).
///
/// \param column is the source column number of this token (should be
///   zero if the column is not known).
///
/// \param text is the textual value of the token (which may be NULL
///   if and only if \c text_len is zero). NUL termination is optional
///   for this parameter, since the length of this string is explicitly
///   given by \c text_len.
///
/// \param text_len is the length of the string given in \c text.
///
/// \return A new token object, initialized with the given parameters,
///   on success.
///
/// \return NULL on error, for example in case of invalid parameters
///   or an out of memory condition.
AsmToken* AsmTokenNew(int type, unsigned line, unsigned column,
		      const char *text, size_t text_len);

/// \brief Deletes a token object and frees any associated memory.
///
/// This function deletes a token and frees any associated memory
/// resources. The function behaves as no-operation if a NULL token
/// objetc is passed as \c token parameter.
///
/// \param[in,out] token The token object to be disposed.
void AsmTokenDelete(AsmToken *token);

/// \brief Gets the source line of the given token.
///
/// This function returns the source line associated with the
/// given token or zero, if the source line is not known.
///
/// \param[in] token The token to be queried.
///
/// \return The source line of the token. The return value
///  may be zero if the source line is unknown or if a NULL
///  pointer is passed as \c token parameter.
unsigned AsmTokenGetLine(const AsmToken *token);

/// \brief Gets the source column of the given token.
///
/// This function returns the source column associated with the
/// given token or zero, if the source column is not known.
///
/// \param[in] token The token to be queried.
///
/// \return The source column of the token. The return value
///  may be zero if the source line is unknown or if a NULL
///  pointer is passed as \c token parameter.
unsigned AsmTokenGetColumn(const AsmToken *token);

/// \brief Gets the textual value of the token as (read-only) C string.
///
/// This function gets the textual value of the token as (read-only) C
/// string. The return value of this function should only be NULL if
/// \c token is NULL. (For tokens without a textual value, the return
/// value should be an empty string).
///
/// \param[in] token The token to be queried.
///
/// \return A read-only NUL-terminated C string with the textual
///   value of the token. (The returned string may be an empty string
///   if the token does not have an associated textual value).
///
/// \return NULL on error (if and only if \c token is NULL).
const char* AsmTokenGetText(const AsmToken *token);

/// \brief Gets the token (type) code of token.
///
/// This function returns the token type code of the given token. The
/// available token type codes can be found in the \c grammar.h file,
/// which is generated by the Lemon parser generator.
///
/// \return The token (type) code of the given token.
///
/// \return NULL on error (if and only if \c token is NULL).
int AsmTokenGetType(const AsmToken *token);

/// @}

//----------------------------------------------------------------------
/// \defgroup AsmLexer Lexical scanner (tokenizer)
/// @{

/// \brief Lexical scanner state.
typedef struct AsmLexer AsmLexer;

/// \brief Lexer operation succeeded.
///
/// This status code is returned by \ref AsmLexerScan when a
/// token has been scanned successfully
#define ASM_LEXER_SUCCESS (0)

/// \brief Lexer encountered the end of file.
///
/// This status code is returned by \ref AsmLexerScan and
/// by \ref AsmLexerReadCallback callbacks when the end of
/// input has been reached.
#define ASM_LEXER_EOF     (-1)

/// \brief Lexer encountered an error.
///
/// This status code is returned by \ref AsmLexerScan and
/// by \ref AsmLexerReadCallback callbacks when a (potentially
/// irrecoverable) error occurred.
#define ASM_LEXER_ERROR   (-2)

/// \brief Lexer character stream read callback.
///
/// This type of callback function is passed to \ref AsmLexerCreate
/// as character stream read callback.
typedef int (*AsmLexerReadCallback)(void* app_data);

/// \brief Lexer stream dispose callback.
///
/// This type of callback function is passed to \ref AsmLexerCreate
/// as character stream dispose callback.
typedef void (*AsmLexerDeleteCallback)(void *app_data);

/// \brief Creates and initializes a new lexer.
///
/// This function creates and initializes a new lexer. The \c read_cb
/// callback function is be used to read characters from input
/// stream of the lexer. The (optional) \c delete_cb function is used to
/// dispose the input stream when the lexer is closed (or when
/// construction of the lexer fails.)
///
/// \param read_cb is the callback function to be used for reading
///   characters from the input stream. This callback function is
///   required.
///
/// \param delete_cb is the optional callback function to be used for
///   disposing the input stream when the lexer is being deleted. (This
///   callback function will also be called, if \ref AsmLexerCreate fails).
///
/// \param app_data is an application specific callback parameter,
///   which will be passed to all invocations of the read and delete
///   callbacks. (\ref AsmLexerCreate does not perform any kind of checking
///   on this value).
///
/// \return The new lexer object, on success.
///
/// \return NULL, on error.
AsmLexer* AsmLexerCreate(AsmLexerReadCallback read_cb,
			 AsmLexerDeleteCallback delete_cb,
			 void *app_data);

/// \cond SKELETON_CODE
/// \brief Creates a lexer for scanning a given input string.
///
/// This function creates a new lexer, which will use the
/// input string given by \c str and \c len as (virtual)
/// character input stream.
///
/// It is the callers responsibility to ensure that the given
/// string remains valid and unchanged for the entire lifetime
/// of the returned lexer object.
///
/// \param[in] str is the string to be used as input source. (The
///   string does not need to be NUL terminated.)
///
/// \param len is the length of the input string.
///
/// \return the new lexer object on success.
///
/// \return NULL on error.
AsmLexer* AsmLexerFromString(const char *str, size_t len);

/// \brief Creates a lexer for scanning a FILE stream.
///
/// This function creates a new lexer, which will use the
/// FILE stream given by \c file as (virtual)
/// character input stream.
///
/// The \c closeOnDelete flag controls ownership of the
/// file stream. Ownership of the stream is immediately transferred
/// from the caller to the function (and on success the created stream)
/// if \c closeOnDelete is true.
///
/// Otherwise (if \c closeOnDelete is false) it is the callers
/// responsibility to ensure  that the given FILE stream remains
/// open for the entire lifetime of the returned lexer object,
/// is \c closeOnDelete is false.
///
///
/// \param file is the file stream to be used as character source.
///   The file stream will be automatically closed on error, if
///   \c closeOnDelete is \c true.
///
/// \param closeOnDelete indicates wether ownership of the FILE
///   stream remains with the caller (\c false) or is immediately
///   passed to the function (\Â¢ true).
///
/// \return the new lexer object on success.
///
/// \return NULL on error.
AsmLexer* AsmLexerFromFile(FILE *file, bool closeOnDelete);
/// \endcond

/// \brief Scans the next token from the lexer's input stream.
///
/// \param[out] ptoken is a pointer to the variable receiving the
///   new token object. (It is the caller's responsibility to dispose
///   the token if needed).
///
/// \param lexer is the lexcial scanner to be used.
///
/// \return \ref ASM_LEXER_SUCCESS if a token was scanned successfully.
///   (\c *ptoken will be a valid pointer to the scanned token).
///
/// \return \ref ASM_LEXER_EOF if the end of file was reached without
///   scanning a new token. (\c *ptoken will be NULL).
///
/// \return \ref ASM_LEXER_ERROR if an error occurred while scanning
///   for the next token. (\c *ptoken will be NULL).
int AsmLexerScan(AsmToken **ptoken, AsmLexer *lexer);

/// \brief Deletes a lexical scanner and relases associated resources.
///
/// This function deletes a lexical scanner object and releases any
/// assoicated resources. If present, the delete callback of the lexer
/// will be invoked to dispose the underlying input source.
///
/// \param lexer is the lexer to be disposed.
void AsmLexerDelete(AsmLexer *lexer);

/// \brief Gets the current line number of the lexer.
///
/// This function is mostly used during error reporting, to indicate
/// the approximate location of a lexer error.
///
/// \param lexer is the lexer to be queried.
///
/// \return The current line number of the lexer (or zero if no
///   precise line information is available).
unsigned AsmLexerGetLine(AsmLexer *lexer);

/// \brief Gets the current column number of the lexer.
///
/// This function is mostly used during error reporting, to indicate
/// the approximate location of a lexer error.
///
/// \param lexer is the lexer to be queried.
///
/// \return The current column number of the lexer. Column number
///   zero should be reported if no precise line information is available.
unsigned AsmLexerGetColumn(AsmLexer *lexer);

/// @}

/// \cond SKELETON_CODE
//----------------------------------------------------------------------
/// \defgroup AsmApi Public assembler API interface (for testing)
/// @{

/// \brief Verbosity level of the assembler.
typedef enum AsmVerbosityLevel {
  /// \brief Quiet mode; do not show output messages.
  ASM_VERBOSITY_QUIET = 0,

  /// \brief Only show error message produced by \ref AsmError.
  ASM_VERBOSITY_ERROR = 1,

  /// \brief Show error message (\ref AsmError) and informational messages
  ///  (\ref AsmInfo).
  ASM_VERBOSITY_INFO = 2
}  AsmVerbosityLevel;

/// \brief The tinyasm assembler.
typedef struct Assembler Assembler;

/// \brief Creates a new tinyvm assembler.
///
/// This function allocated and initializes a new tinyvm assembler
/// instance.
///
/// \param verbosity The message verbosity level of the new assembler.
///
/// \param is_bigendian Selects between bigendian (\c true) or
///    little-endian (\c false) mode.
///
/// \return The new assembler object.
Assembler* AsmNew(AsmVerbosityLevel verbosity, bool is_bigendian);

/// \brief Deletes an existing tinyvm assembler.
///
/// \param assembler The assembler to be deleted.
void AsmDelete(Assembler *assembler);

/// \brief Parses tinyvm assembler source code.
///
/// This function consumes the token stream provided by the lexical scanner
/// given in the \c lexer parameter and parses the resulting objects and functions
/// into the given assembler object.
///
/// \param assembler is the assembler object receiving any parsed function and
///   object definitions.
///
/// \param lexer is the lexical scanner providing the source token stream.
///
/// \return \c true if parsing succeeded.
///
/// \return \c false if parsing failed.
bool AsmParse(Assembler *assembler, AsmLexer *lexer);

/// \brief Links the objects and functions known by an assembler.
///
/// This function causes the assembler to attempt to link all currently defined
/// objects and functions. During linking, the assembler attempts to bind all
/// unresolved symbol reference (function names, labels, object names) to concrete
/// symbols and values (handles, jump offsets).
///
/// Linking succeeds iff and only iff all unresolved symbols can be resolved
/// during the process.
///
/// \param assembler is the assembler performing the linking step.
///
/// \return \c true if the linking step succeeded.
///
/// \return \c false if the linking step failed.
bool AsmLink(Assembler* assembler);

/// \brief Gets the number of errors, which have been encounter by an assembler.
///
/// This functions reports the number of errors which have been encountered by an
/// assembler so far. The assembler normally tries to continue on errors, in order
/// to find as many errors as possible in one pass. This function reports the number
/// of errors found so far.
///
/// \param assembler is the assembler to be queried.
///
/// \return The number of errors encountered by the given assembler. (Zero if no
///   errors were encountered).
unsigned AsmGetErrorCount(Assembler *assembler);

/// \brief Emits byte-code output to a byte buffer.
///
/// This function emits the bytecode of an assembled and linked program
/// to the byte buffer specified by the \c dest parameter.
///
/// Calling this function if the error count of the given assembelr is greater
/// than zero, or if the linking step has not been performed successfully may
/// produces invalid results.
///
/// \param dest is the destination byte buffer receiving the bytecode.
///
/// \param assembler is the assembler object with the program to be written.
///
/// \return \c true if the linking step succeeded.
///
/// \return \c false if the linking step failed.
bool AsmWriteToBuffer(Buffer *dest, Assembler *assembler);


/// \brief Tests if error reporting at a given verbosity level is enabled.
///
/// This function tests if error reporting at verbosity level \c level is enabled
/// for the given assembler.
///
/// \param assembler is the assembler to be queried.
///
/// \param level is the verbosity level to be tested.
///
/// \return \c true if message output is enabled for the given level.
///
/// \return \c false if message output is enabled for the given level.
bool AsmIsReportEnabled(Assembler *assembler, AsmVerbosityLevel level);

/// \brief Prints a formatted error message.
///
/// This function prints a formatted error message for an assembler. The message
/// is formatted using the \c vfprintf standard C library function.
///
/// \param assembler is the (optional) assembler object reporting the error.
///
/// \param token is an (optional) token hinting at the source code location.
///
/// \param message is the format string to be passed to \c vfprintf.
///
/// \param ... is the list of format arguments to be passed to  \c vfprintf.
void AsmError(Assembler *assembler, const AsmToken *token, const char *message, ...)
  __attribute__((format(printf, 3, 4)));

/// \brief Prints a formatted informational message.
///
/// This function prints a formatted informational message for an assembler. The message
/// is formatted using the \c vfprintf standard C library function.
///
/// \param assembler is the (optional) assembler object reporting the error.
///
/// \param token is an (optional) token hinting at the source code location.
///
/// \param message is the format string to be passed to \c vfprintf.
///
/// \param ... is the list of format arguments to be passed to  \c vfprintf.
void AsmInfo(Assembler *assembler, const AsmToken *token, const char *message, ...)
  __attribute__((format(printf, 3, 4)));

/// @}
/// \endcond
#endif // TINYVM_ASSEMBLER_LEXER_H 1
